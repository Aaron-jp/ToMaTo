DHCP_OP_REQUEST = 1
DHCP_OP_REPLY = 2
DHCP_OPTION_VALUE_DISCOVER = "\x01"
DHCP_OPTION_VALUE_OFFER = "\x02"
DHCP_OPTION_VALUE_REQUEST = "\x03"
DHCP_OPTION_VALUE_DECLINE = "\x04"
DHCP_OPTION_VALUE_ACK = "\x05"
DHCP_OPTION_VALUE_NACK = "\x06"
DHCP_MAGIC_COOKIE = "\x63\x82\x53\x63"
DHCP_OPTION_MSG_TYPE = 53
DHCP_OPTION_NETMASK = 1
DHCP_OPTION_GATEWAY = 3
DHCP_OPTION_DOMAIN = 15
DHCP_OPTION_LEASE_TIME = 51
DHCP_OPTION_DHCP_SERVER = 54
DHCP_OPTION_NAMESERVER = 6
DHCP_OPTION_END = 0xff

def dhcp_decode(p):
    h = Header()
    (h.op, h.htype, h.hlen, h.hops, h.xid, h.secs, h.flags) = struct.unpack("!4BIHH", p[0:12])
    h.ciaddr = p[12:16]
    h.yiaddr = p[16:20]
    h.siaddr = p[20:24]
    h.giaddr = p[24:28]
    h.chaddr = p[28:28+h.hlen]
    h.magic_cookie = p[236:240]
    options = p[240:]
    h.options = {}
    pos = 0
    while pos < len(options):
        t = ord(options[pos])
        if t == 0xff:
            break
        l = ord(options[pos+1])
        v = options[pos+2:pos+2+l]
        pos += 2 + l
        h.options[t]=v
    return h 
    
def dhcp_encode(op, xid, ciaddr, yiaddr, siaddr, giaddr, chaddr, options, htype=1, hlen=6, hops=0, secs=0, flags=0, magic_cookie=DHCP_MAGIC_COOKIE):
    p = struct.pack("!4BIHH", op, htype, hlen, hops, xid, secs, flags) + ciaddr + yiaddr + siaddr + giaddr + chaddr + ("\00" * (16 - hlen)) + "\00"*192 + magic_cookie
    options_raw = []
    for key in options:
        options_raw.append(struct.pack("!BB", key, len(options[key])))
        options_raw.append(options[key])
    options_raw.append(struct.pack("!BB", DHCP_OPTION_END, 0))
    p += "".join(options_raw)
    return p