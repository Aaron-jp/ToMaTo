#include <ethernet_node.repy>
#include <arp_proto.repy>
#include <ip_proto.repy>

class FastPing:
    def handle(self, dev, p):
        if p[0:6] == self.mac and p[12:16] == "\x08\x00\x45\x00" and p[23] == "\x01" and p[30:34] == self.ip and p[34:36] == "\x08\x00":
            r = p[6:12] + self.mac + p[12:24] + "\00\00" + self.ip + p[26:30] + "\x00\x00\x00\x00" + p[38:]
            r = r[0:24] + ip_checksum_fast(r[14:34], rev=True) + r[26:34] + r[34:36] + ip_checksum_fast(r[34:], rev=True) + r[38:]
            send(dev, r)
        else:
            EthernetNode.handle(self, dev, p)

class IPNode(EthernetNode):
    def __init__(self, ip, answer_arp=True, **kwargs):
        EthernetNode.__init__(self, **kwargs)
        self.ip = ip
        self.answer_arp = answer_arp
        self.arp_table = {}
    def handle_ethernet(self, ethernet, dev):
        if ethernet.type == ETHERNET_TYPE_ARP:
            arp = arp_decode(ethernet.payload)
            self.handle_arp(arp, ethernet, dev)
        if ethernet.type == ETHERNET_TYPE_IP:
            ip = ip_decode(ethernet.payload)
            if not ip.checksum_correct:
                echo("Invalid IP chechsum")
                return
            #FIXME: reassable fragmented packets
            self.arp_table[ip.src] = ethernet.src
            if ip.dst == self.ip or ip.dst == "\xff\xff\xff\xff":
                self.handle_ip(ip, ethernet, dev)
            else:
                echo(repr(ip.dst))
    def handle_arp(self, arp, ethernet, dev):
        if arp.htype != ARP_HTYPE_ETHERNET or arp.ptype != ARP_PTYPE_IP:
            return
        if self.answer_arp and arp.oper == ARP_OPER_REQUEST and arp.tpa == self.ip:
            arp_reply = arp_encode(arp.htype, arp.ptype, arp.hlen, arp.plen, ARP_OPER_REPLY, self.mac, self.ip, arp.sha, arp.spa)
            EthernetNode.send(self, ethernet.src, ETHERNET_TYPE_ARP, arp_reply)
        if arp.oper == ARP_OPER_REPLY:
            self.arp_table[arp.sda]=arp.sha
            #FIXME: send cached packets
    def handle_ip(self, ip, ethernet, dev):
        pass
    def send(self, dst, protocol, payload, ether_dst=None, dev=None, **kwargs):
        if not ether_dst:
            ether_dst = self.arp_table.get(dst)
        #FIXME: fragment
        #FIXME: send arp request and cache packet if ether_dst still None
        packet = ip_encode(self.ip, dst, protocol, payload, **kwargs)
        EthernetNode.send(self, ether_dst, ETHERNET_TYPE_IP, packet, dev=dev)
