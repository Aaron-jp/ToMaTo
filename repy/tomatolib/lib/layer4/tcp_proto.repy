
#ifndef tcp_proto_loaded
#define tcp_proto_loaded

#include <layer3/ip_proto.repy>

IP_PROTOCOL_TCP = 6

def tcp_decode(p, ip_src, ip_dst):
    h = Header()
    (h.src, h.dst, h.seq_num, h.ack_num, offs_flags, h.window) = struct.unpack("!HHIIHH", p[0:16])
    checksum = p[16:18]
    h.urg_ptr = struct.unpack("!H", p[18:20])
    offset = offs_flags >> 12
    h.fin_flag = offs_flags & 0x1
    h.syn_flag = offs_flags & 0x2
    h.rst_flag = offs_flags & 0x4
    h.psh_flag = offs_flags & 0x8
    h.ack_flag = offs_flags & 0x10
    h.urg_flag = offs_flags & 0x20
    h.options = p[20:4*offset]
    h.payload = p[4*offset:]
    pseudo_header = ip_src + ip_dst + struct.pack("!HH", 6, len(p))
    h.checksum_correct = ip_checksum(pseudo_header + p) == 0
    return h

def tcp_encode(ip_src, ip_dst, src, dst, seq_num, ack_num, window, payload, fin_flag=0, syn_flag=0, rst_flag=0, psh_flag=0, ack_flag=1, urg_flag=0, options="", urg_ptr=0):
    offset = 5 + len(options)/4
    flags = ((urg_flag & 0x01) << 5) | ((ack_flag & 0x01) << 4) | ((psh_flag & 0x01) << 3) | ((rst_flag & 0x01) << 2) | ((syn_flag & 0x01) << 1) | (fin_flag & 0x01)
    offs_flags = (offset << 12) | flags
    p = struct.pack("!HHIIHHHH", src, dst, seq_num, ack_num, offs_flags, window, 0, urg_ptr) + options + payload
    pseudo_header = ip_src + ip_dst + struct.pack("!HH", 6, len(p))
    checksum = struct.pack("!H", ip_checksum(pseudo_header + p)^0xffff)
    p = p[:16] + checksum + p[18:]
    return p

#endif