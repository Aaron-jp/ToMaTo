
#ifndef ip_node_loaded
#define ip_node_loaded

#include <layer2/ethernet_node.repy>
#include <layer2/arp_proto.repy>
#include <layer3/ip_proto.repy>

class FastPing:
    def handle(self, dev, p):
        if p[0:6] == self.mac and p[12:16] == "\x08\x00\x45\x00" and p[23] == "\x01" and p[30:34] == self.ip and p[34:36] == "\x08\x00":
            r = p[6:12] + self.mac + p[12:24] + "\00\00" + self.ip + p[26:30] + "\x00\x00\x00\x00" + p[38:]
            r = r[0:24] + ip_checksum_fast(r[14:34], rev=True) + r[26:34] + r[34:36] + ip_checksum_fast(r[34:], rev=True) + r[38:]
            send(dev, r)
        else:
            EthernetNode.handle(self, dev, p)

class IPNode(EthernetNode):
    def __init__(self, ip, answer_arp=True, **kwargs):
        EthernetNode.__init__(self, **kwargs)
        self.ip = ip
        self.answer_arp = answer_arp
        self.arp_table = {}
        try:
            self.ip_handlers
        except:
            self.ip_handlers = {}
        EthernetNode.bind(self, ETHERNET_TYPE_ARP, self._arp)
        EthernetNode.bind(self, ETHERNET_TYPE_IP, self._ip)
    def bind(self, protocol, handler):
        self.ip_handlers[protocol] = handler
    def _arp(self, ethernet, dev):
        arp = arp_decode(ethernet.payload)
        self.handle_arp(arp, ethernet, dev)
    def _ip(self, ethernet, dev):
        ip = ip_decode(ethernet.payload)
        if not ip.checksum_correct:
            echo("Invalid IP chechsum")
            return
        #FIXME: reassable fragmented packets
        self.arp_table[ip.src] = ethernet.src
        if ip.dst == self.ip or ip.dst == "\xff\xff\xff\xff":
            self.handle_ip(ip, ethernet, dev)
        else:
            echo(repr(ip.dst))
    def handle_arp(self, arp, ethernet, dev):
        if arp.htype != ARP_HTYPE_ETHERNET or arp.ptype != ARP_PTYPE_IP:
            return
        if self.answer_arp and arp.oper == ARP_OPER_REQUEST and arp.tpa == self.ip:
            arp_reply = arp_encode(arp.htype, arp.ptype, arp.hlen, arp.plen, ARP_OPER_REPLY, self.mac, self.ip, arp.sha, arp.spa)
            EthernetNode.send(self, ethernet.src, ETHERNET_TYPE_ARP, arp_reply)
        if arp.oper == ARP_OPER_REPLY:
            self.arp_table[arp.sda]=arp.sha
            #FIXME: send cached packets
    def handle_ip(self, ip, ethernet, dev):
        handler = self.ip_handlers.get(ip.protocol)
        if handler:
            handler(ip, ethernet, dev)
    def send(self, dst, protocol, payload, ether_dst=None, dev=None, **kwargs):
        if not ether_dst:
            ether_dst = self.arp_table.get(dst)
        #FIXME: fragment
        #FIXME: send arp request and cache packet if ether_dst still None
        packet = ip_encode(self.ip, dst, protocol, payload, **kwargs)
        EthernetNode.send(self, ether_dst, ETHERNET_TYPE_IP, packet, dev=dev)

#endif