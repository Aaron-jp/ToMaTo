
#ifndef ip_proto_loaded
#define ip_proto_loaded

ETHERNET_TYPE_IP = 0x0800

def ip_checksum(data):
    if len(data) & 1:
        data = data + "\x00"
    words = struct.unpack("!%dH" % (len(data)/2), data)
    sum = 0
    for w in words:
        sum += w^0xffff
    while sum >> 16:
        sum = (sum>>16) + (sum&0xffff)
    sum ^= 0xffff
    return sum

def ip_decode(p):
    h = Header()
    (version_ihl, tos, h.length, h.id, flags_frag_off, h.ttl, h.protocol, h.checksum) = struct.unpack("!BBHHHBBH", p[0:12])
    h.version = version_ihl >> 4
    h.ihl = version_ihl & 0x0f
    h.dscp = tos >> 2
    h.ecn = tos & 0x03
    flags = flags_frag_off >> 13
    h.dont_fragment = flags & 0x02
    h.more_fragments = flags & 0x01
    h.fragment_offset = flags_frag_off & 0x1fff
    h.src = p[12:16]
    h.dst = p[16:20]
    h.options = []
    for i in range(5, h.ihl):
        h.options.append(p[4*i:4*i+4])
    hlen = 4 * h.ihl
    h.payload = p[hlen:]
    h.checksum_correct = ip_checksum(p[0:hlen]) == 0
    return h

def ip_encode(src, dst, protocol, payload, options=[], version=4, dscp=0, ecn=0, id=0, dont_fragment=0, more_fragments=0, fragment_offset=0, ttl=64):
    ihl = 5 + len(options)
    version_ihl = ((version & 0x0f) << 4) | (ihl & 0x0f)
    tos = ((dscp & 0x1f) << 2) | (ecn & 0x03)
    length = 4 * ihl + len(payload)
    flags = ((dont_fragment & 0x01) << 1) | (more_fragments & 0x01)
    flags_frag_off = ((flags & 0x07) << 13) | (fragment_offset & 0x1fff)
    p = struct.pack("!BBHHHBBH", version_ihl, tos, length, id, flags_frag_off, ttl, protocol, 0) + src + dst + "".join(options)
    p = p[0:10] + struct.pack("!H", ip_checksum(p)^0xffff) + p[12:] + payload
    return p

#endif