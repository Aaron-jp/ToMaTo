
#ifndef ip_proto_loaded
#define ip_proto_loaded

ETHERNET_TYPE_IP = 0x0800

def ip_checksum(data):
    words = struct.unpack("!%dH" % (len(data)/2), data)
    sum = 0
    for w in words:
        sum += w^0xffff
    sum = ((sum>>16) + (sum&0xffff)) & 0xffff
    sum ^= 0xffff
    return sum

def ip_checksum_fast(data, rev=False):
    i = 0
    l = len(data)
    sum = 0
    while i < l:
        w = (ord(data[i])<<8) + ord(data[i+1])
        sum += w^0xffff
        i+=2
    sum = (sum>>16) + (sum&0xffff) & 0xffff
    if not rev: #yes!
        sum ^= 0xffff
    return chr(sum>>8) + chr(sum&0xff)

def ip_decode(p):
    h = Header()
    (version_ihl, tos, h.length, h.id, flags_frag_off, h.ttl, h.protocol, h.checksum) = struct.unpack("!BBHHHBBH", p[0:12])
    h.version = version_ihl >> 4
    h.ihl = version_ihl & 0x0f
    h.dscp = tos >> 2
    h.ecn = tos & 0x03
    h.flags = flags_frag_off >> 13
    h.fragment_offset = flags_frag_off & 0x1fff
    h.src = p[12:16]
    h.dst = p[16:20]
    h.options = []
    for i in range(5, h.ihl):
        h.options.append(p[4*i:4*i+4])
    hlen = 4 * h.ihl
    h.payload = p[hlen:]
    h.checksum_correct = ip_checksum(p[0:hlen]) == 0
    return h

def ip_encode(src, dst, protocol, payload, options=[], version=4, dscp=0, ecn=0, id=0, flags=0, fragment_offset=0, ttl=64):
    ihl = 5 + len(options)
    version_ihl = ((version & 0x0f) << 4) + (ihl & 0x0f)
    tos = ((dscp & 0x1f) << 2) + (ecn & 0x03)
    length = 4 * ihl + len(payload)
    flags_frag_off = ((flags & 0x07) << 13) + (fragment_offset & 0x1fff)
    p = struct.pack("!BBHHHBBH", version_ihl, tos, length, id, flags_frag_off, ttl, protocol, 0) + src + dst + "".join(options)
    p = p[0:10] + struct.pack("!H", ip_checksum(p)^0xffff) + p[12:] + payload
    return p

#endif